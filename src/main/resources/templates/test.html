<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>极简 Hash + 进度</title>
</head>
<body>

<h3>请选择文件：</h3>
<input id="file" type="file">

<script th:src="@{/libs/spark-md5.min.js}"></script>
<script th:src="@{/libs/axios.min.js}"></script>
<script>
    const fileInput = document.getElementById('file');
    const CHUNK_SIZE = 1024 * 1024;

    async function cutFile(file) {
        return new Promise(resolve => {
            const chunkCount = Math.ceil(file.size / CHUNK_SIZE);
            const threadChunkCount = Math.ceil(chunkCount / (navigator.hardwareConcurrency || 4));
            const result = [];
            let finishCount = 0;

            for (let i = 0; i < (navigator.hardwareConcurrency || 4); i++) {
                const worker = new Worker('/libs/worker.js');
                const start = i * threadChunkCount;
                let end = (i + 1) * threadChunkCount;

                if (end > chunkCount) {
                    end = chunkCount;
                }

                worker.postMessage({
                    file,
                    CHUNK_SIZE,
                    startChunkIndex: start,
                    endChunkIndex: end
                });

                worker.onmessage = e => {
                    for (let j = start; j < end; j++) {
                        result[j] = e.data[j - start];
                    }
                    worker.terminate();
                    finishCount++;

                    if (finishCount === (navigator.hardwareConcurrency || 4)) {
                        resolve(result);
                    }
                };
            }
        });
    }

    async function computeFileHash(chunkList) {
        const spark = new SparkMD5();
        for (let chunk of chunkList) {
            spark.append(chunk.hash);
        }
        return spark.end();
    }

    async function _getUploadId(file, fileHash, totalParts) {
        try {
            const response = await axios.post('/api/upload/init', {
                fileName: file.name,
                fileSize: file.size,
                fileHash,
                totalParts
            });
            return response.data;
        } catch (error) {
            console.error('请求 uploadId 失败：', error);
            throw error;
        }
    }

    async function uploadPart(uploadId, index, chunk, file) {
        const formData = new FormData();
        formData.append("uploadId", uploadId);
        formData.append("partIndex", index);
        formData.append("file", chunk.blob);
        formData.append("fileName", file.name);

        return axios.post('/api/upload/part', formData, {
            onUploadProgress: (e) => {
                const percent = ((e.loaded / e.total) * 100).toFixed(2);
                console.log(`分片 ${index} 上传进度: ${percent}%`);
            }
        });
    }

    async function mergeFile(uploadId, fileName) {
        return axios.post('/api/upload/merge', {
            uploadId,
            fileName
        });
    }

    fileInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        try {
            const chunks = await cutFile(file);
            const fileHash = await computeFileHash(chunks);
            const { result: { uploadId, partIndex, isSkip, filePath } } = await _getUploadId(file, fileHash, chunks.length);

            if (isSkip) {
                alert('该文件已秒传成功，文件路径：' + filePath);
                return;
            }

            // 上传每一块（支持断点续传）
            for (let i = partIndex; i < chunks.length; i++) {
                console.log(`开始上传分片 ${i}...`);
                await uploadPart(uploadId, i, chunks[i], file);
                console.log(`分片 ${i} 上传完成`);
            }

            // 所有分片上传完，通知服务端合并
            await mergeFile(uploadId, file.name);
            alert("上传成功！文件路径：" + filePath);

        } catch (err) {
            console.error('上传过程失败：', err);
        }
    });
</script>

</body>
</html>
